SEQUENCE
	msgVersion INTEGER ( 0 .. 2147483647 ),
	msgGlobalData HeaderData,
	{
		msgID      INTEGER (0..2147483647),
		msgMaxSize INTEGER (484..2147483647),
		msgFlags   OCTET STRING (SIZE(1)),
		msgSecurityModel INTEGER (1..2147483647)
	}
	msgSecurityParameters OCTET STRING,
		Si estamos usando USM, almacena la serialización de esto
		{
			msgAuthoritativeEngineID     OCTET STRING,
              		msgAuthoritativeEngineBoots  INTEGER (0..2147483647),
             		msgAuthoritativeEngineTime   INTEGER (0..2147483647),
              		msgUserName                  OCTET STRING (SIZE(0..32)),
              		msgAuthenticationParameters  OCTET STRING,
              		msgPrivacyParameters         OCTET STRING
		}
	msgData  ScopedPduData	// SE ENCRIPTA A PARTIR DE AQUI
	{
		contextEngineID  OCTET STRING,
		contextName      OCTET STRING,
		PDU de SNMPv2 (sin cabecera SNMPv2)
	}

TRAPS: agente manda el trap con su engineID (NO MANDAR REPORT, PORQUE NO ES UN PDU "REPORTABLE"), aceptar si engineID y userName estan bien
INFORM: Te envia el agente el inform-request -> responder con un getresponse si el engineID y el userName estan bien
    REPORT: mandar cuando el inform no tengan bien el engineID o el userName
        - Cuando mandemos un GET al agente, puede mandar un report en vez del get-response, debemos capturarlo y mostrar el error que tiene
        - En un GET al agente, el primer paso de obtener el engineID no es necesario si ya lo tenemos

RFC3412 para saber que es cada campo
RFC3414 para modelo USM
	2.6 sobre claves
	6,7 algoritmo MD5 y SHA para autenticación
	8 algoritmo CBC-DES para confidencialidad
	A para pasar de password a clave

